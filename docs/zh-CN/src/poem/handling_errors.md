# Handling errors

In `Poem`, we handle errors based on the response status code. When the status code is in `400-599`, we can think that 
an error occurred while processing this request.

We can use `EndpointExt::after` to create a new endpoint type to customize the error response.

In the following example, the `after` function is used to convert the output of the `index` function and output an error
response when an server error occurs.

**Note that the endpoint type generated by a `handler` macro is always `Endpoint<Output=Response>`, even if it returns 
a `Result<T>`.**

```rust
use poem::{handler, Result, Error};
use poem::http::StatusCode;

#[handler]
async fn index() -> Result<()> {
    Err(Error::new(StatusCode::BAD_REQUEST))
}

let ep = index.after(|resp| {
    if resp.status().is_server_error() {
        Response::builder()
            .status(resp.status())
            .body("custom error")
    } else {
        resp
    }
});
```

The `EndpointExt::map_to_result` function can help us convert any type of endpoint to `Endpoint<Output = Response>`, so 
that we only need to check the status code to know whether an error has occurred.

```rust
use poem::endpoint::make;
use poem::{Error, EndpointExt};
use poem::http::StatusCode;

let ep = make(|_| Ok::<(), Error>(Error::new(StatusCode::new(Status::BAD_REQUEST))))
    .map_to_response();
    
let ep = ep.after(|resp| {
    if resp.status().is_server_error() {
        Response::builder()
            .status(resp.status())
            .body("custom error")
    } else {
        resp
    }
});
```

## poem::Error

`poem::Error` is a general error type, which implements `From<T: Display>`, so you can easily use the `?` operator to 
convert any error type to it. The default status code is `503 Internal Server Error`.

```rust
use poem::Result;

#[handler]
fn index(data: Vec<u8>) -> Result<i32> {
    let value: i32 = serde_json::from_slice(&data)?;
    Ok(value)
}
```

But sometimes we don't want to always use the `503` status code, `Poem` provides some helper functions to convert the error type.

```rust
use poem::{Result, web::Json, error::BadRequest};

#[handler]
fn index(data: Vec<u8>) -> Result<Json<i32>> {
    let value: i32 = serde_json::from_slice(&data).map_err(BadRequest)?;
    Ok(Json(value))
}
```

## Custom error type

Sometimes we can use custom error types to reduce boilerplate code.

NOTE: `Poem`'s error types usually only needs to implement `IntoResponse`. 

```rust
use poem::{
    Response,
    error::ReadBodyError,
    http::StatusCode,
};

enum MyError {
    InvalidValue,
    ReadBodyError(ReadBodyError),
}

impl IntoResponse for MyError {
    fn into_response(self) -> Response {
        match self {
            MyError::InvalidValue => Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .body("invalid value"),
            MyError::ReadBodyError(err) => err.into(), // ReadBodyError has implemented `IntoResponse`.
        }
    }
}

#[handler]
fn index(data: Result<String, ReadBodyError>) -> Result<(), MyError> {
    let data = data?;
    if data.len() > 10 {
        return Err(MyError::InvalidValue);
    }
}
```
